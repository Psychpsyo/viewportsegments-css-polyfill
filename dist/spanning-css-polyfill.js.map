{"version":3,"file":"spanning-css-polyfill.js","sources":["../src/constants.js","../src/utils/css-text-processors.js","../src/utils/misc.js","../src/index.js","../src/utils/device-geometry.js"],"sourcesContent":["export const SPANNING_MF_KEY = \"spanning\";\nexport const SPANNING_MF_VAL_HOR = \"single-fold-horizontal\";\nexport const SPANNING_MF_VAL_VER = \"single-fold-vertical\";\nexport const SPANNING_MF_VAL_NONE = \"none\";\n\nexport const CSS_ENV_FOLD_TOP = \"fold-top\";\nexport const CSS_ENV_FOLD_LEFT = \"fold-left\";\nexport const CSS_ENV_FOLD_HEIGHT = \"fold-height\";\nexport const CSS_ENV_FOLD_WIDTH = \"fold-width\";\n\nexport const POLYFILL_NAMESPACE = \"__foldables_env_vars__\";\n","import {\n  SPANNING_MF_KEY,\n  SPANNING_MF_VAL_HOR,\n  SPANNING_MF_VAL_VER,\n  SPANNING_MF_VAL_NONE\n} from \"../constants.js\";\n\nconst SPANNING_MEDIA_BLOCK_REGEXP_STR = `(@media.*?\\\\b${SPANNING_MF_KEY}\\\\b[^{]+)\\\\{([\\\\s\\\\S]+?\\\\})\\\\s*\\\\}`;\n\nconst MEDIA_FEATURES_REGEXP = /\\((.*?)\\)/gi;\n\nconst MEDIA_TYPES_REGEXP = /@media[^\\(]+/gi;\n\nconst cssEnvVariableRegExpMaker = variable => {\n  return new RegExp(`env\\\\(\\\\s*${variable}\\\\s*\\\\)`, \"gi\");\n};\n\n/**\n * Finds and returns an array of `@media` blocks with containing spanning media feature\n *\n * @param {string} cssText\n *\n * @returns {string[]}\n */\nexport function _processSpanningMediaBlock(cssText) {\n  const regex = new RegExp(SPANNING_MEDIA_BLOCK_REGEXP_STR, \"gi\");\n\n  let spanningMediaBlocks;\n  if(typeof cssText.matchAll === \"function\") {\n    spanningMediaBlocks = Array.from(cssText.matchAll(regex));\n  }else{\n    spanningMediaBlocks = [];\n\n    while(spanningMediaBlocks[spanningMediaBlocks.length]=regex.exec(cssText));\n    spanningMediaBlocks.length--;\n  }\n  return spanningMediaBlocks;\n}\n\n/**\n * Replaces spanning `@media` blocks containing `spanning` feature\n * and returns a new stylesheet string\n *\n * @param {String} originalSheetStr\n * @param {String} replaceWith\n *\n * @returns {String}\n */\nexport function replaceSpanningMediaBlocks(originalSheetStr, replaceWith) {\n  return originalSheetStr.replace(\n    new RegExp(SPANNING_MEDIA_BLOCK_REGEXP_STR, \"gi\"),\n    replaceWith\n  );\n}\n\n/**\n * Replaces a word in a string and returns a new string\n *\n * @param {String} originalSheetStr\n * @param {String} cssEnvVariable\n * @param {String} replaceWith\n *\n * @returns {String}\n */\nexport function replaceCSSEnvVariables(\n  originalSheetStr,\n  cssEnvVariable,\n  replaceWith\n) {\n  return originalSheetStr.replace(\n    cssEnvVariableRegExpMaker(cssEnvVariable),\n    replaceWith\n  );\n}\n\n/**\n * Returns an array of media features found a string sucb as\n * `(min-width: ..)`, `(orientation:..)` etc.\n *\n * @param {String[]} mediaQueryStr\n *\n * @returns {String[]}\n */\nexport function _getMediaFeatures(mediaQueryStr) {\n  return mediaQueryStr.match(MEDIA_FEATURES_REGEXP) || [];\n}\n\n/**\n * Returns an array containing `@media` and following media types such\n * as screen, all, print, etc. up until the first media feature parenthesis\n *\n * @param {*} mediaQueryStr\n *\n * @returns {String[]}\n */\nexport function _getMediaTypes(mediaQueryStr) {\n  return mediaQueryStr.match(MEDIA_TYPES_REGEXP) || [];\n}\n\n/**\n * Finds all spanning media queries in CSS text and returns an object of all media\n * queries, grouped by type\n *\n * @param {*} cssText\n */\nexport function getSpanningCSSText(cssText) {\n  const spanningMediaBlocks = _processSpanningMediaBlock(cssText);\n\n  const result = {\n    [SPANNING_MF_VAL_HOR]: \"\",\n    [SPANNING_MF_VAL_VER]: \"\",\n    [SPANNING_MF_VAL_NONE]: \"\"\n  };\n\n  spanningMediaBlocks.forEach(block => {\n    const definition = block[1];\n    const content = block[2];\n\n    //TODO: this is bad.\n    let spanningValue = SPANNING_MF_VAL_NONE;\n    if (definition.indexOf(SPANNING_MF_VAL_HOR) > -1) {\n      spanningValue = SPANNING_MF_VAL_HOR;\n    }\n    if (definition.indexOf(SPANNING_MF_VAL_VER) > -1) {\n      spanningValue = SPANNING_MF_VAL_VER;\n    }\n\n    const mediaTypes = _getMediaTypes(definition);\n    let mediaFeatures = _getMediaFeatures(definition);\n\n    mediaFeatures = mediaFeatures\n      .filter(f => !f.includes(SPANNING_MF_KEY))\n      .join(\" and \");\n\n    result[spanningValue] += `\n      ${mediaTypes} ${mediaFeatures} {\n        ${content}\n      }`;\n  });\n\n  return result;\n}\n","/**\n * Returns a promise, once resolved it contains an array\n * of CSS text retrieved from <link> URLs and <style> DOM elements\n *\n * @param {array} elements JavaScript array (not NodeList)\n *\n * @return {Promise<string[]>}\n */\nexport function fetchCSSText(elements) {\n  return Promise.all(\n    elements.map(element => {\n      const href = element.href;\n      if (href) {\n        return fetch(href).then(r => r.text());\n      }\n      return element.textContent;\n    })\n  );\n}\n\n/**\n * Returns a function that won't call `fn` if it was invoked at a\n * faster interval than `wait`\n *\n * @param {Function} fn\n * @param {Number} wait - milliseconds\n */\nexport function debounce(fn, wait) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn.apply(this, arguments), wait);\n  };\n}\n\n/**\n *\n * @param {String} name\n * @param {Object} attributes\n * @param {String} content\n *\n * @return {DOM Node}\n */\nexport function createElement(name, attributes, content) {\n  const el = document.createElement(name);\n  Object.keys(attributes).forEach(k => {\n    el.setAttribute(k, attributes[k])\n  })\n  if (typeof content !== typeof(undefined)) {\n    el.textContent = content;\n  }\n  return el;\n}","\n/**\n * This is the documentation for the CSS spanning polyfill. There are only\n * few methods available.\n *\n * @projectname Spanning CSS Polyfill\n * @version 1.0\n * @author Zouhir Chahoud\n * @author Kenneth Christiansen\n * @author Alexis Menard\n * @copyright 2020\n *\n */\nimport {\n  POLYFILL_NAMESPACE,\n  SPANNING_MF_VAL_NONE,\n  SPANNING_MF_VAL_VER,\n  SPANNING_MF_VAL_HOR\n} from \"./constants.js\";\n\nimport {\n  getSpanningCSSText,\n  replaceSpanningMediaBlocks,\n  replaceCSSEnvVariables\n} from \"./utils/css-text-processors.js\";\n\nimport { getDeviceFoldRects } from \"./utils/device-geometry.js\";\n\nimport { fetchCSSText, debounce, createElement } from \"./utils/misc.js\";\n\nif (typeof window[POLYFILL_NAMESPACE] === typeof(undefined)) {\n  // polyfill configuration related variables\n  const spanning =\n    sessionStorage.getItem(`${POLYFILL_NAMESPACE}-spanning`) ||\n    SPANNING_MF_VAL_NONE;\n  const foldSize =\n    +sessionStorage.getItem(`${POLYFILL_NAMESPACE}-foldSize`) || 0;\n  const browserShellSize =\n    +sessionStorage.getItem(`${POLYFILL_NAMESPACE}-browserShellSize`) || 0;\n  // global configs, accessible via the window object\n  Object.defineProperty(window, POLYFILL_NAMESPACE, {\n    value: {\n      spanning,\n      foldSize,\n      browserShellSize,\n      update: update,\n      onupdate: [insertSpanningStyles]\n    }\n  });\n\n  // Web-based emulator runs this polyfill in an iframe, we need to\n  // communicate emulator state changes to the site.\n  // Should only be registered once (in CSS or JS polyfill not both)\n  window.addEventListener(\"message\", evt => {\n    const action = evt.data.action || \"\";\n    const value = evt.data.value || {};\n    if (action === \"update\") {\n      window[POLYFILL_NAMESPACE].update(value);\n    }\n  });\n} else {\n  window[POLYFILL_NAMESPACE].onupdate.push(insertSpanningStyles);\n}\n\nconst cssElements = Array.from(\n  document.querySelectorAll('link[rel=\"stylesheet\"], style')\n);\n\n/*\n * modified page CSS text: env(fold-*) variables replaced (spanning: *) media query replaced\n * grouped in this object as:\n *\n * -- single-fold-vertical: CSS found in the media feature (spanning: single-fold-vertical)\n * -- single-fold-horizontal: CSS found in the media feature (spanning: single-fold-horizontal)\n * -- none: CSS found in the media feature (spanning: none)\n */\nconst spanning = {\n  [SPANNING_MF_VAL_HOR]: \"\",\n  [SPANNING_MF_VAL_VER]: \"\",\n  [SPANNING_MF_VAL_NONE]: \"\"\n};\n\n/** Replace the spanning media queries according to their configuration.\n * This is useful for web components with their own style sheets.\n * @param {HTMLElement} element - The element.\n * @param {CSSStyleSheet} sheet - The stylesheet to update.\n*/\nexport function adjustCSS(elementName, sheet) {\n  const noSpanningCSS = replaceSpanningMediaBlocks(sheet, \"\");\n  const spanningCSS = getSpanningCSSText(sheet);\n\n  spanning[elementName] = {\n    [SPANNING_MF_VAL_HOR]: \"\",\n    [SPANNING_MF_VAL_VER]: \"\",\n    [SPANNING_MF_VAL_NONE]: \"\"\n  };\n\n  Object.keys(spanningCSS).forEach(k => {\n    if (typeof spanning[elementName][k] !== typeof(undefined)) {\n      spanning[elementName][k] += `\n        /* origin: ${elementName} */\n        ${spanningCSS[k]}`;\n    }\n  });\n\n  spanning[elementName][\"non-spanning\"] = noSpanningCSS;\n  return noSpanningCSS;\n}\n\n/** Register the element to make sure it's get updated whenever the\n * configuration changed.\n * @param {HTMLElement} element - The element.\n*/\nexport function observe(element) {\n  insertSpanningStyles(element);\n  window.addEventListener(\"resize\", key => debounce(element => insertSpanningStyles(element), 150));\n  window[POLYFILL_NAMESPACE].onupdate.push(() => insertSpanningStyles(element));\n}\n\nfetchCSSText(cssElements).then(sheetsTextContentArray => {\n  const styleFragment = new DocumentFragment();\n  sheetsTextContentArray.forEach((sheet, i) => {\n    // all other css excluding spanning media blocks\n    const noSpanningCSS = replaceSpanningMediaBlocks(sheet, \"\");\n    const spanningCSS = getSpanningCSSText(sheet);\n\n    const sheetOrigin = cssElements[i].href || \"inline\";\n\n    Object.keys(spanningCSS).forEach(k => {\n      if (typeof spanning[k] !== typeof(undefined)) {\n        spanning[k] += `\n          /* origin:  ${sheetOrigin} */\n          ${spanningCSS[k]}`;\n      }\n    });\n\n    styleFragment.appendChild(\n      createElement(\"style\", { \"data-css-origin\": sheetOrigin }, noSpanningCSS)\n    );\n  });\n\n  // Spanning media blocks grouped by spanning type (single-fold-horizontal, vertical or none)\n  // let spanningCSSText = getSpanningCSSText(cssText);\n  // editedCSSText = Object.assign(editedCSSText, spanningCSSText);\n\n  cssElements.forEach(el => el.parentElement.removeChild(el));\n\n  document.head.appendChild(styleFragment);\n\n  // insert spanning media query stylesheet\n  insertSpanningStyles();\n\n  window.addEventListener(\"resize\", () => debounce(insertSpanningStyles, 150));\n});\n\n// looks at configs and appends the correct `spanning` styles\nfunction insertSpanningStyles(element) {\n  if (element) {\n    Array.from(element.shadowRoot.querySelectorAll(`.${POLYFILL_NAMESPACE}`)).forEach(el =>\n      el.parentNode.removeChild(el)\n    );\n  } else {\n    Array.from(document.querySelectorAll(`.${POLYFILL_NAMESPACE}`)).forEach(el =>\n      el.parentElement.removeChild(el)\n    );\n  }\n  let configs = window[POLYFILL_NAMESPACE];\n\n  let spanningCSSText = element ?\n    spanning[element.nodeName.toLowerCase()][configs.spanning] :\n    spanning[configs.spanning];\n\n  let noSpanningCSSText = element ?\n    spanning[element.nodeName.toLowerCase()][\"non-spanning\"] : null;\n\n  let rects = getDeviceFoldRects(configs);\n\n  Object.keys(rects).forEach(r => {\n    spanningCSSText = replaceCSSEnvVariables(\n      spanningCSSText,\n      r,\n      `${rects[r]}px`\n    );\n  });\n\n  let polyfilledStyles = document.createElement(\"style\");\n  polyfilledStyles.className = POLYFILL_NAMESPACE;\n  polyfilledStyles.textContent = spanningCSSText;\n  if (element) {\n    const shadowRoot = element.shadowRoot;\n    if (\"adoptedStyleSheets\" in shadowRoot && shadowRoot.adoptedStyleSheets.length > 0) {\n      shadowRoot.adoptedStyleSheets[0].replace(noSpanningCSSText + spanningCSSText);\n    } else {\n      shadowRoot.appendChild(polyfilledStyles);\n    }\n  } else {\n    document.head.appendChild(polyfilledStyles);\n  }\n}\n\n/**\n *\n * @typedef Configuration\n * @type {object}\n * @property {number} foldSize - The size in CSS pixel of the fold.\n * @property {number} browserShellSize - The size in CSS pixel of the browser shell.\n * @property {string} spanning - The current spanning mode : single-fold-horizontal, single-fold-vertical or none.\n */\nconst VALID_CONFIG_PROPS = new Set([\n  \"foldSize\",\n  \"browserShellSize\",\n  \"spanning\"\n]);\n\n/** Update the current configuration to a new one.\n * @param {Configuration} configuration - The new configuration.\n*/\nexport function update(newConfings) {\n  Object.keys(newConfings).forEach(k => {\n    if (VALID_CONFIG_PROPS.has(k)) {\n      window[POLYFILL_NAMESPACE][k] = newConfings[k];\n      sessionStorage.setItem(\n        `${POLYFILL_NAMESPACE}-${k}`,\n        window[POLYFILL_NAMESPACE][k]\n      );\n    }\n  });\n\n  window[POLYFILL_NAMESPACE].onupdate.forEach(fn => fn());\n}\n","import {\n  SPANNING_MF_VAL_VER,\n  SPANNING_MF_VAL_HOR,\n  CSS_ENV_FOLD_TOP,\n  CSS_ENV_FOLD_LEFT,\n  CSS_ENV_FOLD_HEIGHT,\n  CSS_ENV_FOLD_WIDTH\n} from \"../constants.js\";\n\n/**\n * Returns the device fold (hinge) geometry\n *\n * @param {Object} configs\n * @returns {Object}\n */\nexport function getDeviceFoldRects(configs) {\n  let left = 0,\n    top = 0,\n    width = 0,\n    height = 0;\n  if (configs.spanning === SPANNING_MF_VAL_VER) {\n    width = configs.foldSize;\n    height = window.innerHeight;\n    left = window.innerWidth / 2 - configs.foldSize / 2;\n  }\n  if (configs.spanning === SPANNING_MF_VAL_HOR) {\n    width = window.innerWidth;\n    height = configs.foldSize;\n    top =\n      ((window.innerHeight - configs.browserShellSize) / 2) - (configs.foldSize / 2);\n  }\n  return {\n    [CSS_ENV_FOLD_TOP]: top,\n    [CSS_ENV_FOLD_LEFT]: left,\n    [CSS_ENV_FOLD_HEIGHT]: height,\n    [CSS_ENV_FOLD_WIDTH]: width\n  };\n}\n"],"names":["const","SPANNING_MF_KEY","SPANNING_MF_VAL_HOR","SPANNING_MF_VAL_VER","SPANNING_MF_VAL_NONE","CSS_ENV_FOLD_TOP","CSS_ENV_FOLD_LEFT","CSS_ENV_FOLD_HEIGHT","CSS_ENV_FOLD_WIDTH","POLYFILL_NAMESPACE","SPANNING_MEDIA_BLOCK_REGEXP_STR","MEDIA_FEATURES_REGEXP","MEDIA_TYPES_REGEXP","cssEnvVariableRegExpMaker","variable","RegExp","replaceSpanningMediaBlocks","originalSheetStr","replaceWith","replace","getSpanningCSSText","cssText","spanningMediaBlocks","regex","matchAll","Array","from","length","exec","_processSpanningMediaBlock","result","forEach","block","definition","content","spanningValue","indexOf","mediaTypes","match","mediaFeatures","filter","f","includes","join","debounce","fn","wait","timeout","clearTimeout","setTimeout","apply","this","arguments","window","spanning","sessionStorage","getItem","foldSize","browserShellSize","Object","defineProperty","value","update","onupdate","insertSpanningStyles","addEventListener","evt","data","action","push","elements","cssElements","document","querySelectorAll","adjustCSS","elementName","sheet","noSpanningCSS","spanningCSS","keys","k","observe","element","key","shadowRoot","el","parentNode","removeChild","parentElement","configs","spanningCSSText","nodeName","toLowerCase","noSpanningCSSText","rects","left","top","width","height","innerHeight","innerWidth","getDeviceFoldRects","r","polyfilledStyles","createElement","className","textContent","adoptedStyleSheets","appendChild","head","Promise","all","map","href","fetch","then","text","sheetsTextContentArray","styleFragment","DocumentFragment","i","attributes","sheetOrigin","setAttribute","VALID_CONFIG_PROPS","Set","newConfings","has","setItem"],"mappings":"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"}
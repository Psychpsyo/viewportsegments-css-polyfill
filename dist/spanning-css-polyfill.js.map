{"version":3,"file":"spanning-css-polyfill.js","sources":["../src/constants.js","../src/utils/css-text-processors.js","../src/index.js","../src/utils/misc.js","../src/utils/device-gemoetry.js"],"sourcesContent":["export const SPANNING_MF_KEY = \"spanning\";\nexport const SPANNING_MF_VAL_HOR = \"single-fold-horizontal\";\nexport const SPANNING_MF_VAL_VER = \"single-fold-vertical\";\nexport const SPANNING_MF_VAL_NONE = \"none\";\n\nexport const CSS_ENV_FOLD_TOP = \"fold-top\";\nexport const CSS_ENV_FOLD_LEFT = \"fold-left\";\nexport const CSS_ENV_FOLD_HEIGHT = \"fold-height\";\nexport const CSS_ENV_FOLD_WIDTH = \"fold-width\";\n\nexport const POLYFILL_NAMESPACE = \"__foldables_env_vars__\";\n","import {\n  SPANNING_MF_KEY,\n  SPANNING_MF_VAL_HOR,\n  SPANNING_MF_VAL_VER,\n  SPANNING_MF_VAL_NONE\n} from \"../constants.js\";\n\nconst SPANNING_MEDIA_BLOCK_REGEXP_STR = `(@media.*?\\\\b${SPANNING_MF_KEY}\\\\b[^{]+)\\\\{([\\\\s\\\\S]+?\\\\})\\\\s*\\\\}`;\n\nconst MEDIA_FEATURES_REGEXP = /\\((.*?)\\)/gi;\n\nconst MEDIA_TYPES_REGEXP = /@media[^\\(]+/gi;\n\nconst cssEnvVariableRegExpMaker = variable => {\n  return new RegExp(`env\\\\(\\\\s*${variable}\\\\s*\\\\)`, \"gi\");\n};\n\n/**\n * Finds and returns an array of `@media` blocks with containing spanning media feature\n *\n * @param {string} cssText\n *\n * @returns {string[]}\n */\nexport function _processSpanningMediaBlock(cssText) {\n  let regex = new RegExp(SPANNING_MEDIA_BLOCK_REGEXP_STR, \"gi\");\n\n  // mathAll is not yet supported in Safari but shipped in Edge, Chrome and FF\n  // Accoding to Babel docs: https://babeljs.io/docs/en/babel-preset-env#shippedproposals\n  // setting {useBuiltIns: \"usage\"} will use the browser shipped version than the transpiled\n  let spanningMediaBlocks = Array.from(cssText.matchAll(regex));\n\n  return spanningMediaBlocks;\n}\n\n/**\n * Replaces spanning `@media` blocks containning `spanning` feature and returns a new string\n *\n * @param {String} originalSheetStr\n * @param {String} replaceWith\n *\n * @returns {String}\n */\nexport function replaceSpanningMediaBlocks(originalSheetStr, replaceWith) {\n  return originalSheetStr.replace(\n    new RegExp(SPANNING_MEDIA_BLOCK_REGEXP_STR, \"gi\"),\n    replaceWith\n  );\n}\n\n/**\n * Replaces a word in a string and returns a new string\n *\n * @param {String} originalSheetStr\n * @param {String} cssEnvVariable\n * @param {String} replaceWith\n *\n * @returns {String}\n */\nexport function replaceCSSEnvVariables(\n  originalSheetStr,\n  cssEnvVariable,\n  replaceWith\n) {\n  return originalSheetStr.replace(\n    cssEnvVariableRegExpMaker(cssEnvVariable),\n    replaceWith\n  );\n}\n\n/**\n * Returns an array of media features found a string sucb as `(min-width: ..)`, `(orientation:..)` etc..\n *\n * @param {String[]} mediaQueryStr\n *\n * @returns {String[]}\n */\nexport function _getMediaFeatures(mediaQueryStr) {\n  return mediaQueryStr.match(MEDIA_FEATURES_REGEXP) || [];\n}\n\n/**\n * Returns an array containing `@media` and following media types such as screen, all, print, etc.\n * up until the first media feature parentheses\n *\n * @param {*} mediaQueryStr\n *\n * @returns {String[]}\n */\nexport function _getMediaTypes(mediaQueryStr) {\n  return mediaQueryStr.match(MEDIA_TYPES_REGEXP) || [];\n}\n\n/**\n * Finds all spanning media queries in CSS text and returns an object of all media\n * queries grouped by type\n *\n * @param {*} cssText\n */\nexport function getSpanningCSSText(cssText) {\n  let spanningMediaBlocks = _processSpanningMediaBlock(cssText);\n\n  let result = {\n    [SPANNING_MF_VAL_HOR]: \"\",\n    [SPANNING_MF_VAL_VER]: \"\",\n    [SPANNING_MF_VAL_NONE]: \"\"\n  };\n\n  spanningMediaBlocks.forEach(block => {\n    let defintion = block[1];\n    let content = block[2];\n\n    //TODO: this is bad.\n    let spanningValue = SPANNING_MF_VAL_NONE;\n    if (defintion.indexOf(SPANNING_MF_VAL_HOR) > -1) {\n      spanningValue = SPANNING_MF_VAL_HOR;\n    }\n    if (defintion.indexOf(SPANNING_MF_VAL_VER) > -1) {\n      spanningValue = SPANNING_MF_VAL_VER;\n    }\n\n    let mediaTypes = _getMediaTypes(defintion);\n    let mediaFeatures = _getMediaFeatures(defintion);\n\n    mediaFeatures = mediaFeatures\n      .filter(f => !f.includes(SPANNING_MF_KEY))\n      .join(\" and \");\n\n    result[spanningValue] += `\n      ${mediaTypes} ${mediaFeatures} {\n        ${content}\n      }`;\n  });\n\n  return result;\n}\n","import {\n  SPANNING_MF_VAL_NONE,\n  POLYFILL_NAMESPACE,\n  SPANNING_MF_VAL_VER,\n  SPANNING_MF_VAL_HOR\n} from \"./constants.js\";\n\nimport {\n  getSpanningCSSText,\n  replaceSpanningMediaBlocks,\n  replaceCSSEnvVariables\n} from \"./utils/css-text-processors.js\";\n\nimport { getDeviceFoldRects } from \"./utils/device-gemoetry.js\";\n\nimport { fetchCSSText, debounnce, createElement } from \"./utils/misc.js\";\n\nif (typeof window[POLYFILL_NAMESPACE] === \"undefined\") {\n  // polyfill configuration related variables\n  let spanning =\n    sessionStorage.getItem(`${POLYFILL_NAMESPACE}-spanning`) ||\n    SPANNING_MF_VAL_NONE;\n  let foldSize = sessionStorage.getItem(`${POLYFILL_NAMESPACE}-foldSize`) || 0;\n  let browserShellSize =\n    sessionStorage.getItem(`${POLYFILL_NAMESPACE}-browserShellSize`) || 0;\n  // global configs, accessible via the window object\n  Object.defineProperty(window, POLYFILL_NAMESPACE, {\n    value: {\n      spanning,\n      foldSize,\n      browserShellSize,\n      update: update,\n      onupdate: [insertSpanningStyles]\n    }\n  });\n\n  // web-based emulator runs this polyfill in an iframe, we need to communicate\n  // emulator state changes to the site\n  // should only be registered once (in CSS or JS polyfill not both)\n  window.addEventListener(\"message\", evt => {\n    let action = evt.data.action || \"\";\n    let value = evt.data.value || {};\n    if (action === \"update\") {\n      window[POLYFILL_NAMESPACE].update(value);\n    }\n  });\n}\n\nlet cssElements = Array.from(\n  document.querySelectorAll('link[rel=\"stylesheet\"], style')\n);\n\n// original page CSS\n//let cssText = \"\";\n\n/**\n * modified page CSS text: env(fold-*) variables replaced, (spanning: *) media query replaced\n * grouped in this object as:\n *\n * -- single-fold-vertical: CSS found in the media feature (spanning: single-fold-vertical)\n * -- single-fold-horizontal: CSS found in the media feature (spanning: single-fold-horizontal)\n * -- none: CSS found in the media feature (spanning: none)\n */\nlet spanning = {\n  [SPANNING_MF_VAL_HOR]: \"\",\n  [SPANNING_MF_VAL_VER]: \"\",\n  [SPANNING_MF_VAL_NONE]: \"\"\n};\n\nfetchCSSText(cssElements).then(sheetsTextContentArray => {\n  let styleFragment = new DocumentFragment();\n  sheetsTextContentArray.forEach((sheet, i) => {\n\n    // all other css excluding spanning media blocks\n    let noSpanningCSS = replaceSpanningMediaBlocks(sheet, \"\");\n    let spanningCSS = getSpanningCSSText(sheet);\n\n    let sheetOrigin = cssElements[i].href || \"inline\";\n\n    Object.keys(spanningCSS).forEach(k => {\n      if (typeof spanning[k] !== \"undefined\") {\n        spanning[k] += `\n          /* origin:  ${sheetOrigin} */\n          ${spanningCSS[k]}`;\n      }\n    });\n\n    styleFragment.appendChild(\n      createElement(\"style\", { \"data-css-origin\": sheetOrigin }, noSpanningCSS)\n    );\n  });\n\n  // spanning media blocks grouped by spanning type (single-fold-horizontal, vertical or none)\n  // let spanningCSSText = getSpanningCSSText(cssText);\n  // editedCSSText = Object.assign(editedCSSText, spanningCSSText);\n\n  cssElements.forEach(el => el.parentElement.removeChild(el));\n\n  document.head.appendChild(styleFragment);\n\n  // insert spanning media query styelsheet\n  insertSpanningStyles();\n\n  window.addEventListener(\"resize\", debounnce(insertSpanningStyles, 150));\n});\n\n// looks at configs and appends the correct `spanning` styles\nfunction insertSpanningStyles() {\n  Array.from(document.querySelectorAll(`.${POLYFILL_NAMESPACE}`)).forEach(el =>\n    el.parentElement.removeChild(el)\n  );\n  let configs = window[POLYFILL_NAMESPACE];\n\n  if (configs.spanning === SPANNING_MF_VAL_NONE) return;\n\n  let spanningCSSText = spanning[configs.spanning];\n  let rects = getDeviceFoldRects(configs);\n\n  Object.keys(rects).forEach(r => {\n    spanningCSSText = replaceCSSEnvVariables(\n      spanningCSSText,\n      r,\n      `${rects[r]}px`\n    );\n  });\n\n  let polyfilledStyles = document.createElement(\"style\");\n  polyfilledStyles.className = POLYFILL_NAMESPACE;\n  polyfilledStyles.textContent = spanningCSSText;\n  document.head.appendChild(polyfilledStyles);\n}\n\nconst VALID_CONFIG_PROPS = new Set([\n  \"foldSize\",\n  \"browserShellSize\",\n  \"spanning\"\n]);\n\nfunction update(newConfings) {\n  Object.keys(newConfings).forEach(k => {\n    if (VALID_CONFIG_PROPS.has(k)) {\n      window[POLYFILL_NAMESPACE][k] = newConfings[k];\n      sessionStorage.setItem(\n        `${POLYFILL_NAMESPACE}-${k}`,\n        window[POLYFILL_NAMESPACE][k]\n      );\n    }\n  });\n\n  window[POLYFILL_NAMESPACE].onupdate.forEach(fn => fn());\n}\n","/**\n * Returns a promise, once resolved it contains an array\n * of CSS text retrieved from <link> URLs and <style> DOM elements\n *\n * @param {array} elements JavaScript array (not NodeList)\n *\n * @return {Promise<string[]>}\n */\nexport function fetchCSSText(elements) {\n  return Promise.all(\n    elements.map(element => {\n      let href = element.href;\n      if (href) {\n        return fetch(href).then(r => r.text());\n      }\n      return element.textContent;\n    })\n  );\n}\n\n/**\n * Returns a function that won't call `fn` if it was invoked at a faster interval than `wait`\n *\n * @param {Function} fn\n * @param {Number} wait - milliseconds\n */\nexport function debounnce(fn, wait) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn.apply(this, arguments), wait);\n  };\n}\n\n/**\n * \n * @param {String} name \n * @param {Object} attributes \n * @param {String} content \n * \n * @return {DOM Node}\n */\nexport function createElement(name, attributes, content) {\n  let el = document.createElement(name);\n  Object.keys(attributes).forEach(k => {\n    el.setAttribute( k, attributes[k] )\n  })\n  if( typeof content !== 'undefined') {\n    el.textContent = content\n  }\n  return el;\n}","import {\n  SPANNING_MF_VAL_VER,\n  SPANNING_MF_VAL_HOR,\n  CSS_ENV_FOLD_TOP,\n  CSS_ENV_FOLD_LEFT,\n  CSS_ENV_FOLD_HEIGHT,\n  CSS_ENV_FOLD_WIDTH\n} from \"../constants.js\";\n\n/**\n * Returns the device fold (hinge) geometry\n *\n * @param {Object} configs\n * @returns {Object}\n */\nexport function getDeviceFoldRects(configs) {\n  let left = 0,\n    top = 0,\n    width = 0,\n    height = 0;\n  if (configs.spanning === SPANNING_MF_VAL_VER) {\n    width = configs.foldSize;\n    height = window.innerHeight;\n    left = window.innerWidth / 2 - configs.foldSize / 2;\n  }\n  if (configs.spanning === SPANNING_MF_VAL_HOR) {\n    width = window.innerWidth;\n    height = configs.foldSize;\n    top =\n      window.innerHeight / 2 - configs.foldSize / 2 - configs.browserShellSize;\n  }\n  return {\n    [CSS_ENV_FOLD_TOP]: top,\n    [CSS_ENV_FOLD_LEFT]: left,\n    [CSS_ENV_FOLD_HEIGHT]: height,\n    [CSS_ENV_FOLD_WIDTH]: width\n  };\n}\n"],"names":["const","SPANNING_MF_VAL_HOR","SPANNING_MF_VAL_VER","SPANNING_MF_VAL_NONE","CSS_ENV_FOLD_TOP","CSS_ENV_FOLD_LEFT","CSS_ENV_FOLD_HEIGHT","CSS_ENV_FOLD_WIDTH","POLYFILL_NAMESPACE","MEDIA_FEATURES_REGEXP","MEDIA_TYPES_REGEXP","cssEnvVariableRegExpMaker","variable","RegExp","window","spanning","sessionStorage","getItem","foldSize","browserShellSize","Object","defineProperty","value","update","newConfings","keys","forEach","k","VALID_CONFIG_PROPS","has","setItem","onupdate","fn","insertSpanningStyles","addEventListener","evt","data","action","let","elements","cssElements","Array","from","document","querySelectorAll","el","parentElement","removeChild","configs","spanningCSSText","rects","left","top","width","height","innerHeight","innerWidth","getDeviceFoldRects","r","replaceWith","replace","polyfilledStyles","createElement","className","textContent","head","appendChild","Promise","all","map","element","href","fetch","then","text","sheetsTextContentArray","timeout","styleFragment","DocumentFragment","sheet","i","attributes","content","spanningMediaBlocks","result","noSpanningCSS","spanningCSS","cssText","regex","matchAll","_processSpanningMediaBlock","block","defintion","spanningValue","indexOf","mediaTypes","match","mediaFeatures","filter","f","includes","join","sheetOrigin","setAttribute","clearTimeout","setTimeout","apply","this","arguments","Set"],"mappings":"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"}